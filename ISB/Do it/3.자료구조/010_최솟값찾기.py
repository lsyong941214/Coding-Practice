'''
N의 크기가 500만 이므로, O(N)안에 해결 해야한다.
슬라이딩윈도우를 사용하더라도, 이 슬라이딩 윈도우에서 최솟값을 찾으려면, 반복문안에서 추가적으로 O(L)이 걸리므로 시간초과가 발생한다.
즉, 최소값을 찾는데에 슬라이딩윈도우 내에서 반복문을 사용하면 안된다
슬라이딩윈도우에서 왼쪽값이 삭제되고, 오른쪽 추가됨에 따라 최소값을 구해서 반복문 없이 해결해보려고 했으나, 이런식으론 해결할 수 없었다.
정답을 살짝 확인 해보니 덱을 사용했길래, 덱을 써서 해결해보려고 했으나 실패했다 -> 덱자료구조도 결국 min값을 찾으려면 O(L)의 시간복잡도가 필요하기 때문. 덱 자료구조 + 반복문을 안쓰는 어떤 아이디어가 필요함.
결국 정답 보면서 그 아이디어를 이해했다.
덱에 (인덱스, 값)을 append/pop하여 오름차순 정렬효과를 통해 반복문 없이 최소값을 가져올 수 있었다.

[ 메모 ]
덱자료구조의 len()은 O(1)인데, 왜 반복문안에서 사용하면 시간초과가 발생하지..?
'''

from collections import deque
import sys
input = sys.stdin.readline

N, L = map(int, input().split())
A = list(map(int, input().split()))
q = deque()
answer = [] 

for i in range(N):
    # A[i]보다 큰 데이터들 덱에서 제거
    # len(q) -> 시간초과 발생
    while q and q[-1][1] > A[i]:
        q.pop()
    # 덱 뒤에 A[i] 삽입
    q.append((i+1, A[i]))

    # 덱의 가장 앞 인덱스가 범위를 초과하는경우 덱에서 제거
    if q[0][0] <= i-L+1 :
        q.popleft()
    
    print(q[0][1], end=' ')


'''
12 3
1 5 2 3 6 2 3 7 3 5 2 6
Out = 1 1 1 2 2 2 2 2 3 3 2 2
'''
