'''
O(NlogN)안에 문제를 해결할 수 있는 아이디어를 떠올리는게 포인트다.
전혀 감이 오질않아 답지를 보고 이해했다.
버블소트를 위해 수행한 반복문의 횟수가 정답이고, 구하는 방식으로는 정렬 전후의 인덱스차이를 이용했다.
버블소트는 내부반복문을 통해 왼쪽으로 단 한 칸씩만 이동 가능하기 때문에, 왼쪽으로 움직인 거리가 가장 큰 값이 반복횟수가 된다.
반복횟수는 정렬 전후 인덱스차이를 통해 쉽게 구할 수 있다.
아이디어는 실전에서 떠올리기 상당히 어려워보인다.... 풀이는 설명이 따로 필요없을 정도로 간단하다.
'''
import sys
input = sys.stdin.readline

n = int(input())
arr = []

for i in range(n):
    # 입력 값과 인덱스를 튜플형태로 저장한다.
    arr.append((int(input()), i))

# 파이썬 디폴트 정렬함수를 이용, 정렬 기준: 튜플의 첫번째 원소(사용자 입력 값) -> N(nlogn)
sort_arr = sorted(arr)

max_val = int(1e9) * -1
for idx in range(len(sort_arr)):
    # 이전 인덱스는 튜플의 두번째 인자에 저장되어 있고 현재 인덱스는 반복문 변수에 정의되어있다.
    # 이 두개를 뺄셈하여 이동한 거리를 계산하고, Max값을 구한다.
    max_val = max(max_val, sort_arr[idx][1]-idx)

print(max_val + 1)
'''
5
10
1
5
2
3
'''